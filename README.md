# Attacking the licensing problems with C++

From the early days of the commercialization of computer software, malicious
programmers, also known as crackers have been continuously nettling the
programmers of aforementioned software by constantly bypassing the clever
licensing mechanisms they have implemented in their software, thus causing
financial damages to the companies providing the software.

This trend has not changed in recent years, the more clever routines the
programmers write, the more time is spent by the crackers to invalidate the
newly created routines, and at the end the crackers always succeed. For the
companies to be able to keep up with the constant pressure provided by the
cracking community they would need to constantly change the licensing and
identification algorithms, but in practice this is not a feasible way to
deal with the problem.

An entire industry has evolved around software protection and licensing
technologies, where renowned companies offer advanced (and expensive) solutions
to tackle this problem. The protection schemes vary from using various resources
such as hardware dongles, to network activation, from unique license keys to
using complex encryption of personalized data, the list is long.

This article will provide a short introduction to illustrate a very simple and
naive licensing algorithms' internal workings, we will show how to bypass it
in an almost real life scenario, and finally present a software based approach
to mitigate the real problem by hiding the license checking code in a layer of
obfuscated operations generated by the C++ template metaprogramming framework
which will make the life of the person wanting to crack the application a little
bit harder. Certainly, if they are well determined, the code will also be
cracked at some point, but at least we'll make it harder for them.

# A naive licensing algorithm

The naive licensing algorithm is a very simple implementation of checking the
validity of a license associated with the name of the user who has purchased the
associated software. It is NOT an industrial strength algorithm, it has just
demonstrative power, while trying to provide insight on the actual
responsibilities of a real licensing algorithm.

Since the license checking code is usually shipped with the software product
in compiled form, I'll put in here both the generated code (in Intel x86
assembly) since that is what the crackers will see after a successful
disassembly of the executable but also the C++ code for the licensing algorithm.
In order to not to pollute the precious paper space with unintelligible binary
code I will restrain myself to include only the relevant bits of the code, with
regard to the parts which naively determines whether a supplied license is valid
or not, together with the C++ code, which was used to generate the binary code.

The code was compiled using Microsoft Visual C++ (2015), in Release mode with
optimization settings to favour a smaller executable, and I also have used the
built in debugger of the VS IDE, to have a proper matching of the generated
code with the source, to facilitate the educational aspect of this article.

The following is the source code of the licensing algorithm:

```cpp
static const char letters[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
bool check_license(const char* user, const char* users_license)
{
    std::string license;
    size_t ll = strlen(users_license);
    size_t l = strlen(user), lic_ctr = 0;
    int add = 0;

    for (size_t i = 0; i < ll; i++)
        if (users_license[i] != '-')
            license += users_license[i];

    while (lic_ctr < license.length() ) {
        size_t i = lic_ctr;
        i %= l;
        int current = 0;
        while (i < l) current += user[i ++];
        current += add;
        add++;
        if (license[lic_ctr] != letters[current % sizeof letters])
            return false;
        lic_ctr++;
    }
    return true;
}
```

The license which this method validates comes in the form of the following
"ABCD-EFGH-IJKL-MNOP" and there is an associated `generate_license` method which
will be presented as an appendix to this article.

The interesting part is the binary code of the method with annotations to
recognize the corresponding C++ code:

```cpp
if (license[lic_ctr] != letters[current % sizeof letters])
    00FC15E4  lea         ecx,[license]  
if (license[lic_ctr] != letters[current % sizeof letters])
    00FC15E7  cmovae      ecx,dword ptr [license]  
    00FC15EB  xor         edx,edx  
    00FC15ED  push        1Bh  
    00FC15EF  pop         esi  
    00FC15F0  div         eax,esi  
    00FC15F2  mov         eax,dword ptr [lic_ctr]  
    00FC15F5  mov         al,byte ptr [ecx+eax]  
    00FC15F8  cmp         al,byte ptr [edx+0FC42A4h]  
    00FC15FE  jne         check_license+0DEh (0FC1625h)  
    return false;
lic_ctr++;
    00FC1600  mov         eax,dword ptr [lic_ctr]  
    00FC1603  mov         ecx,dword ptr [add]  
    00FC1606  inc         eax  
    00FC1607  mov         dword ptr [lic_ctr],eax  
    00FC160A  cmp         eax,dword ptr [ebp-18h]  
    00FC160D  jb          check_license+7Fh (0FC15C6h)  
}
return true;
    00FC160F  mov         bl,1  
    00FC1611  push        0  
    00FC1613  push        1  
    00FC1615  lea         ecx,[license]  
    00FC1618  call        std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy (0FC1944h)  
    00FC161D  mov         al,bl  
}
    00FC161F  call        _EH_epilog3_GS (0FC2F7Ch)  
    00FC1624  ret  
    00FC1625  xor         bl,bl  
    00FC1627  jmp         check_license+0CAh (0FC1611h)
```

Also, the naivety of this method is exposed by using the very proper
`check_license` name which immediately reveals to the up-to-be attacker where to
look for the code checking the ... license. If you want to make harder for the
attacker the identification of the license checking method I'd recommend either
to use some irrelevant names orjust strip all symbols from the executable as
part of the release process.

After identifying the method responsible for verifying the validity of the
supplied license, the first instruction the attacker looks for is the `ret`,
signaling to the CPU, this method is about to exit. The most common way of
returning a value from a method call is to place the value in the `eax` register
and let the calling code handle it. For this method the `ret` is to be found at
`00FC1624` 

## The C++ Obfuscating framework

The C++ obfuscating framework provides a simple macro based mechanism for
relevant applications to replace the C++ control structures and statements with
highly obfuscated code which makes the reverse engineering of the product a
complex and complicated procedure.

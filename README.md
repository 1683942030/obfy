# Attacking the licensing problems with C++

From the early days of the commercialization of computer software, malicious
programmers, also known as crackers have been continuously nettling the
programmers of aforementioned software by constantly bypassing the clever
licensing mechanisms they have implemented in their software, thus causing
financial damages to the companies providing the software.

This trend has not changed in recent years, the more clever routines the
programmers write, the more time is spent by the crackers to invalidate the
newly created routines, and at the end the crackers always succeed. For the
companies to be able to keep up with the constant pressure provided by the
cracking community they would need to constantly change the licensing and
identification algorithms, but in practice this is not a feasible way to
deal with the problem.

An entire industry has evolved around software protection and licensing
technologies, where renowned companies offer advanced (and expensive) solutions
to tackle this problem. The protection schemes vary from using various resources
such as hardware dongles, to network activation, from unique license keys to
using complex encryption of personalized data, the list is long.

This article will provide a short introduction to illustrate a very simple and
naive licensing algorithms' internal workings, we will show how to bypass it
in an almost real life scenario, and finally present a software based approach
to mitigate the real problem by hiding the license checking code in a layer of
obfuscated operations generated by the C++ template metaprogramming framework
which will make the life of the person wanting to crack the application a little
bit harder. Certainly, if they are well determined, the code will also be
cracked at some point, but at least we'll make it harder for them.

# A naive licensing algorithm

The naive licensing algorithm is a very simple implementation of checking the
validity of a license associated with the name of the user who has purchased the
associated software. It is NOT an industrial strength algorithm, it has just
demonstrative power, while trying to provide insight on the actual
responsibilities of a real licensing algorithm.

Since the license checking code is usually shipped with the software product
in compiled form, I'll put in here both the generated code (in Intel x86
assembly) since that is what the crackers will see after a successful
disassembly of the executable but also the C++ code for the licensing algorithm.
In order to not to pollute the precious paper space with unintelligible binary
code I will restrain myself to include only the relevant bits of the code, with
regard to the parts which naively determines whether a supplied license is valid
or not, together with the C++ code, which was used to generate the binary code.

The code was compiled using Microsoft Visual C++ (2015), in Release mode with
optimization settings to favour a smaller executable, and I also have used the
built in debugger of the VS IDE, to have a proper matching of the generated
code with the source, to facilitate the educational aspect of this article.

The following is the source code of the licensing algorithm:

```cpp
static const char letters[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
bool check_license(const char* user, const char* users_license)
{
    std::string license;
    size_t ll = strlen(users_license);
    size_t l = strlen(user), lic_ctr = 0;
    int add = 0;

    for (size_t i = 0; i < ll; i++)
        if (users_license[i] != '-')
            license += users_license[i];

    while (lic_ctr < license.length() ) {
        size_t i = lic_ctr;
        i %= l;
        int current = 0;
        while (i < l) current += user[i ++];
        current += add;
        add++;
        if (license[lic_ctr] != letters[current % sizeof letters])
            return false;
        lic_ctr++;
    }
    return true;
}
```

The license which this method validates comes in the form of the following
"ABCD-EFGH-IJKL-MNOP" and there is an associated `generate_license` method which
will be presented as an appendix to this article.

Also, the naivety of this method is exposed by using the very proper
`check_license` name which immediately reveals to the up-to-be attacker where to
look for the code checking the ... license. If you want to make harder for the
attacker the identification of the license checking method I'd recommend either
to use some irrelevant names or just strip all symbols from the executable as
part of the release process.

The interesting part is the binary code of the method obtained via compilation
of the corresponding C++ code. It is intentionally NOT the Debug version, since
we hardly should ship debug version of the code to our customers.

```cpp
if (license[lic_ctr] != letters[current % sizeof letters])
    00FC15E4  lea         ecx,[license]  
    00FC15E7  cmovae      ecx,dword ptr [license]  
    00FC15EB  xor         edx,edx  
    00FC15ED  push        1Bh  
    00FC15EF  pop         esi  
    00FC15F0  div         eax,esi  
    00FC15F2  mov         eax,dword ptr [lic_ctr]  
    00FC15F5  mov         al,byte ptr [ecx+eax]  
    00FC15F8  cmp         al,byte ptr [edx+0FC42A4h]  
    00FC15FE  jne         check_license+0DEh (0FC1625h)  
    return false;
lic_ctr++;
    00FC1600  mov         eax,dword ptr [lic_ctr]  
    00FC1603  mov         ecx,dword ptr [add]  
    00FC1606  inc         eax  
    00FC1607  mov         dword ptr [lic_ctr],eax  
    00FC160A  cmp         eax,dword ptr [ebp-18h]  
    00FC160D  jb          check_license+7Fh (0FC15C6h)  
}
return true;
    00FC160F  mov         bl,1  
    00FC1611  push        0  
    00FC1613  push        1  
    00FC1615  lea         ecx,[license]  
    00FC1618  call        std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy (0FC1944h)  
    00FC161D  mov         al,bl  
}
    00FC161F  call        _EH_epilog3_GS (0FC2F7Ch)  
    00FC1624  ret  
    00FC1625  xor         bl,bl  
    00FC1627  jmp         check_license+0CAh (0FC1611h)
```

Let's analyze it for a short while. The essence of the validity checking happens
at the address `00FC15F8` where the comparison `cmp al, byte ptr [edx+0FC42A4h]`
takes place (for those wondering, `edx` gets its value as being the remainder
of the division at `00FC15F0`).

At this stage the value of the `al` register is already initialized
with the value of `license[lic_ctr]` and that is the actual comparison to see
that it matches the actually expected character. If it does not match, the code
jumps to `0FC1625h` where the `bl` register is zeroed out (`xor bl, bl`) and
from there the jump goes backward to `0FC1611h` to leave the method with the
`ret` instruction found at `00FC1624`. Otherwise the loop continues.

The most common way of returning a value from a method call is to place the
value in the `eax` register and let the calling code handle it, so before
returning from the method the value of `al` is populated with the value of the
`bl` register (via `mov al, bl` found at `00FC161D`).

Please remember, that if the check discussed before did not succeed, the value
of the `bl` register was 0, but this `bl` was initialized to `1` (via `mov bl,1`
at `00FC160F`) in case the entire loop was successfully completed.

If we think from the persepctive of an attacker, the only thing that needs to be
done is to replace in the executable the binary sequence of `xor bl,bl` with the
binary code of `mov bl,1`. Since luckily these two have the same length (2 bytes)
the crack is ready to be published within a few seconds.

Moreover, due to the simplicity of the implementation of the algorithm, a highly
skilled cracker could easily create a key-generator for the application, which
would be an even worse scenario, since the cracker didn't had to to modify the
executable, thus further safety steps, such as integrity checks of the
application would all be executed correctly, but there would be a publicly
available key-generator which could be used by anyone to generate a license-key
without ever paying for it, or malicious salesmen could generate counterfeit
licenses which they could sell to unsuspecting customers.

Here comes in picture our C++ Obfuscating framework.

## The C++ Obfuscating framework

The C++ obfuscating framework provides a simple macro based mechanism combined
with advanced C++ template metaprogramming techniques for relevant methods and
control structures to replace the basic C++ control structures and statements
with highly obfuscated code which makes the reverse engineering of the product a
complex and complicated procedure.

By using the framework the reverse engineering of the license checking algorithm
presented in the previous paragraph would prove to be a highly challenging task
due to the sheer amount of extra code generated by the frameworks engine.

The framework has adopted a familiar, BASIC like syntax to make the switch from
real C++ source code the the macro language of the framework as easy and
painless as possible.

### Functionality of the framework

The role of the obfuscating framework is to generate extra code, while providing
functionality which is expected by the user, with as little as possible syntax
changes to the language as could be achieved.

The following functionalities are provided by the framework:

 - wrap all values into a valueholder class thus hiding them from immediate
   access
 - providing a BASIC like syntax for the basic c++ control structures (if, for,
   while ...)
 - generating extra code to achieve complex code making it harder to understand
 - offering a randomization of constant values in order to hide the information

### Using the framework

The basic usage of the framework boils down to including the header file
providing the obfuscating functionality

```cpp
#include "instr.h"`
```

then using the macro pair `OBF_BEGIN` and `OBF_END` as delimiters of the code
sequences that will be using obfuscated expressions.

#### Value and numerical wrappers

To achieve an extra layer of obfuscation, the numerical values can be wrapped in
the macro `N()` and all numeric variables (`int`, `long`, ...) can be wrapped in
the macro `V()` to provide an extra layer of obfuscation for doing the
calculation operations.

And here is an example for using the value and variable wrappers:

```cpp
int a, b = N(6);
V(a) = N(1);
```

After executing the statement above, the value of `a` will be 1.

The value wrappers implement a limited set of operations which you can use to
change the value of the wrapped variable. These are the compound assignment
operators: `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `>>=`, `&=`, `|=`, `^=` and the
post/pre-increment operations `--` and `++`. All of the binary operators `+`,
`-`, `*`, `/`, `%`, `&`, `|`, `<<`, `>>` are also implemented so you can write
`V(a) + N(1)` or `V(a) - V(b)`.

Also, the assignment operator to a specific type and from a different value
wrapper is implemented, together with the comparison operators.

### Control structures of the framework

The following control structures are made available for immediate use
by the developers by means of macros, which expand into complex templated code.

#### The `if` statement

For checking the true-ness of an expression the framework offers the `IF` macro
which has the following form:

    `IF (expression)`
    `....statements`
    `ELSE`
    `....other statements`
    `ENDIF`

where the `ELSE` is not mandator, but the `ENDIF` is, since it indicates the
end of the `IF` blocks' statements.

And here is an example for the usage of the `IF` macro.

```cpp
IF( V(a) == N(9) )
     V(b) = a + N(5);
ELSE
     V(a) = N(9);
     V(b) = a + b;
ENDIF
```

#### The `for` statement

The macro provided to imitate the `for` statement is:

  `FOR(initializer, condition, incrementer)`
  `.... statements`
  `ENDFOR`

Please note, that since `FOR` is a macro, it should use `,` (comma) not the
traditional `;` which is used in the standard C++ `for` loops, and do not forget
to include your `initializer`, `condition` and `incrementer` in parentheses if
they are expressions which have `,` (comma) in them.

The `FOR` loops should be ended with and `ENDFOR` statement to signal the end of
the structure.

Here is a simple example for the `FOR` loop.

```cpp
FOR(V(a) = N(0), V(a) < N(10), V(a) += 1)
   std::cout << V(a) << std::endl;
ENDFOR
```

### Discommodities of the framework

Since
